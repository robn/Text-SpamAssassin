#!/usr/bin/perl -w
# pragmas
use strict;

use vars qw(
  $CODENAME
  $VERSION
  $PEDIGREE
  %OWNER
);

# ownership boilerplate
%OWNER = (
    'name'  => 'Bob Apthorpe',
    'email' => 'apthorpe+babycart@cynistar.net',
);

# 'phone'=>'',

# internal modules (part of core perl distribution)
use Getopt::Long;
use POSIX qw(strftime);

# external modules (CPAN, etc.)
use Text::SpamAssassin;

# use Mail::SpamAssassin;
# use Mail::SpamAssassin::NoMailAudit;

# use lib qw(/home/apthorpe/pjx/Text/SpamAssassin);
# use SpamAssassin;

# set version info
&set_version();

# handle comand-line options
my %option = ();
&process_options(\%option);

### End boilerplate ###

my $Rh_sa_prefs = ();

# $Rh_sa_prefs->{'rules_filename'} = '/etc/spamassassin.rules';

# You really want to set this to adjust score and ignore Bayes, most
# net tests, and a few HTML tests.
# $Rh_sa_prefs->{'userprefs_filename'} = './comment_spam_prefs.cf';
# $Rh_sa_prefs->{'userprefs_filename'} = '/home/apthorpe/pjx/Text/SpamAssassin/comment_spam_prefs.cf';

##### Refactor 1 - BEGIN
if (defined($option{'rules'}) && (-e $option{'rules'})) {
    $Rh_sa_prefs->{'rules_filename'} = $option{'rules'};
}
delete($Rh_sa_prefs->{'rules_filename'})
  unless (defined($Rh_sa_prefs->{'rules_filename'})
    && (-e $Rh_sa_prefs->{'rules_filename'}));

if (defined($option{'userprefs'}) && (-e $option{'userprefs'})) {
    $Rh_sa_prefs->{'userprefs_filename'} = $option{'userprefs'};
}
delete($Rh_sa_prefs->{'userprefs_filename'})
  unless (defined($Rh_sa_prefs->{'userprefs_filename'})
    && (-e $Rh_sa_prefs->{'userprefs_filename'}));
##### Refactor 1 - END

main:
{

    # Print verdict,note,score,[rules,...] as response.
    # where verdict is OK or SUSPICIOUS
    # note is a description of the results
    # score is a float
    # and [rules,...] is a (possibly empty) comma-delimited list of rules hit.

    # Slurp message from STDIN
    # NB: Limit this to <200KB?
    my $Rl_comment;
    @{$Rl_comment} = <>;

    # Extract (optional) comment metadata from incoming message stream
    my %comment_metadata = ();
    get_comment_metadata($Rl_comment, \%comment_metadata);

    my $tester = Text::SpamAssassin->new(
        'data'               => $Rl_comment,
        'spamassassin_prefs' => $Rh_sa_prefs,
        %comment_metadata,
    );

    my $Rh_response = $tester->analyze;

    my $verdict = $Rh_response->{'verdict'} || 'OK';
    my $response = $verdict;
    foreach my $kk (qw(note score rules)) {
        $response .= ',' . ($Rh_response->{$kk} || '');
    }

    print $response, "\n";

    if ($option{'debug'}) {

        #		Don't poke around under the hood - this is for testing only...
        if ($option{'verbose'}) {
            print STDERR "Fake mail:\n" . $tester->{'_mail'}->as_string . "\n";
        }

        my $Rh_md = $tester->get_metadata();
        print STDERR "Metadata:\n";
        foreach my $kk (keys %{$Rh_md}) {
            print STDERR $kk . ' -> ' . ($Rh_md->{$kk} || '') . "\n";
        }
        print STDERR "\n";

        my $Rh_sa = $tester->get_spamassassin_prefs();
        print STDERR "SA prefs:\n";
        foreach my $kk (keys %{$Rh_sa}) {
            print STDERR $kk . ' -> ' . $Rh_sa->{$kk} . "\n";
        }
        print STDERR "\n";

        print STDERR "Response:\n";
        foreach my $kk (keys %{$Rh_response}) {
            print STDERR $kk . ' -> ' . $Rh_response->{$kk} . "\n";
        }
        print STDERR "\n";
    }

    exit(($verdict eq 'OK') ? 0 : -1);
}

sub get_comment_metadata {
    my $Rl_comment          = shift;
    my $Rh_comment_metadata = shift;

    my $last_card = $#{$Rl_comment};
    my $endhdr    = 0;

  comment_metaloop:
    foreach my $ctr (0 .. $last_card) {
        my $card = $Rl_comment->[$ctr];

        if ($card =~ m/^END_COMMENT_METADATA/io) {
            if ($option{'debug'}) {
                print STDERR "Found END at $ctr\n";
            }
            $endhdr = $ctr;
            last comment_metaloop;
        } elsif ($card =~ m/^(AUTHOR|EMAIL|IP|SUBJECT|URL):\s*(.*)\s*$/i) {
            my ($kk, $vv) = (lc($1), $2);
            chomp $vv;
            $Rh_comment_metadata->{$kk} = $vv;
            if ($option{'debug'}) {
                print STDERR "Found $kk at $ctr\n";
            }
        } else {
            if ($option{'debug'}) {
                print STDERR "ENDING at $ctr\n";
            }
            $endhdr = $ctr;
            last comment_metaloop;
        }
    }

    # Use $endhdr to cut off metadata before analysis, if that's important to
    # you.
    if ($option{'debug'}) {
        print STDERR "End header counter: $endhdr\n";
    }

    return;
}

#####################
sub process_options {
#####################
    my $Rh_opt = shift;

    ### set option types and arguments

    my @optlst = (
        'debug', 'verbose', 'help',    'usage',
        'owner', 'version', 'rules=s', 'userprefs=s'
    );

    ### map options to variables

    foreach my $kk (@optlst) {
        my ($nkk, $junk) = split(/[=!]/, $kk, 2);
        $Rh_opt->{$nkk} = '' if ($nkk);
    }

    GetOptions($Rh_opt, @optlst);

    ### print usage, version, or ownership messages.

    if (   $Rh_opt->{'help'}
        || $Rh_opt->{'usage'}
        || $Rh_opt->{'version'}
        || $Rh_opt->{'owner'}) {
        my $msg = '';

        if ($Rh_opt->{'help'} || $Rh_opt->{'usage'}) {
            $msg .= &show_usage();
        }

        if ($Rh_opt->{'version'}) {
            $msg .= "\n" if ($msg);
            $msg .= &show_version();
        }

        if ($Rh_opt->{'owner'}) {
            $msg .= "\n" if ($msg);
            $msg .= &show_owner();
        }
        print STDERR $msg;
        exit(0);
    }

    return;
}

################
sub show_usage {
################
    my $msg;
    $msg .= <<"USAGE";
Usage: $CODENAME [options]
    --rules=filename        Specify SpamAssassin rules file
    --userprefs=filename    Specify custom SpamAssassin user prefs file
    --verbose               Sets verbose mode
    --debug                 Sets debug mode
    --help                  Displays this message
    --usage                 "        "    "
    --owner                 Shows owner of $CODENAME
    --version               Shows version info for $CODENAME
USAGE

    #" stop pretty printer from barfing on odd number of quotes

    return $msg;
}

################
sub show_owner {
################
    my $msg = '';
    $msg = $CODENAME;
    if ($OWNER{'name'}) {
        $msg .= " is owned by:\n" . $OWNER{'name'} . "\n";
        $msg .= "<" . $OWNER{'email'} . ">\n" if ($OWNER{'email'});
        $msg .= $OWNER{'phone'} . "\n" if ($OWNER{'phone'});
    } else {
        $msg .= " doesn't seem to have an owner. Odd.\n";
    }

    return $msg;
}

##################
sub show_version {
##################
    return $PEDIGREE . "\n";
}

#################
sub set_version {
#################
    ($CODENAME = $0) =~ s#^(.*/)##g;
    ($VERSION) = '$Revision: 1.3 $' =~ m#\$Revision:\s+(\S+)#o;
    my ($revdate) = '$Date: 2004/09/03 01:00:19 $' =~ m#Date:\s+(.+)\s+\$#o;
    $PEDIGREE = $CODENAME . ', Version ' . $VERSION . ' dated ' . $revdate;
    return;
}

__END__
# Add pod here
=pod

=head1 NAME

babycart - Estimates spammishness of arbitrary text stream using SpamAssassin

=head1 SYNOPSIS

	babycart --usage

=head1 VERSION

	$Revision: 1.3 $

=head1 DESCRIPTION

Filters arbitrary text through SpamAssassin, returning comma-delimited response of the form:

 verdict,note,score,[rules,...]

where

=over 4 

=item * verdict is OK or SUSPICIOUS

=item * note is a description of the results

=item * score is a float, and

=item * [rules,...] is a (possibly empty) comma-delimited list of rules hit.

=back

Empty messages are flagged as OK as are unprocessed messages.

The goal of babycart is to check wiki and blog posts for spamminess, especially using the SURBL (www.surbl.org) to detect spammy domains in URLs. I didn't want to rewrite the analyzer from scratch or maintain it so I just used SpamAssassin. SA provides a lot more interesting rules and more flexibility than I could have put into the code.

A limited amount of metadata can be passed before the actual text, e.g.:

=over 4

=item * AUTHOR - the poster's name

=item * EMAIL - the poster's email address

=item * IP - the poster's IP address

=item * SUBJECT - the comment subject

=item * URL - the poster's URL

=item * END_COMMENT_METADATA - terminates metadata

=back

Look at the test cases for examples.

This info isn't analyzed much. It's used to fake up email headers to wrap
around the comment so SpamAssassin doesn't carp too much and it's prepended to
the comment body. Meaning, if a comment spammer is making innocuous (usually
nonsense) comments but spamming via his contact URL, you can check that URL
against SURBL and set the comment to be moderated.

Oh yeah, that's an important point. You just might have bloggers legitimately
commenting on some Viagra story or some such spammy topics. Use babycart to set
posts to be moderated, rather than rejecting them wholesale. Babycart gives you
enough rope to blow your foot off so use it wisely.

=head1 USAGE

 Usage: babycart [options] < comment.txt
     --rules=filename        Specify SpamAssassin rules file
     --userprefs=filename    Specify custom SpamAssassin user prefs file
     --verbose               Sets verbose mode
     --debug                 Sets debug mode
     --help                  Displays this message
     --usage                 "        "    "
     --owner                 Shows owner of babycart
     --version               Shows version info for babycart

=head1 DEPENDENCIES

=over 4

=item * Getopt::Long

=item * Text::SpamAssassin

=back

=head1 BUGS

None known.

=head1 TO DO

Fix bugs. Truncate comment to specified limit. Disable net tests as well as bayes in config file.

=head1 AUTHOR

Bob Apthorpe, apthorpe+babycart@cynistar.net

=head1 SEE ALSO

perl(1), Mail::SpamAssassin.

=cut
